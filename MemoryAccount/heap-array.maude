fmod ACCOUNT{Selector :: TRIV} is
    pr NAT .
    pr INT .
    pr LIST{Selector} .

    sorts IdSelector PersonSelector PrePersonSelector AccSelector Selector PrimarySelector .
    subsort Nat < IdSelector .
    subsort PrimarySelector < IdSelector PersonSelector AccSelector < Selector$Elt .

    op $accounts : -> IdSelector .
    op $name : -> PersonSelector .
    ops $balance $open : -> AccSelector .

    sort Heap Name Boolean Value Identity Key .
    ops tt ff : -> Boolean [ctor] .

    subsort Boolean Name Identity Int < Value .

    op write : Heap Identity Selector$Elt Value -> Heap .
    op write : Heap Value Selector$Elt Value -> Heap .
    op read : Heap Identity NeList{Selector} -> Value .
    op read : Heap Value NeList{Selector} -> Value .
    op new : Heap Identity Nat -> Heap .

    var heap : Heap .
    var n : Nat .
    vars id idW idR : Identity .
    vars idV idWV idRV idSelV : Value .
    vars selector selectorW selectorR : Selector$Elt .
    var idSel : IdSelector .
    var val : Value .
    var neList : NeList{Selector} .
    var selList : List{Selector} .
    var key : Key .
    var primSelector : PrimarySelector .

    mb $name    : PrimarySelector .
    mb $balance : PrimarySelector .
    mb $open    : PrimarySelector .

    op isNewId : Value -> Bool .

    eq isNewId(read(new(heap, id, n), idR, neList)) = true .
    ceq isNewId(read(heap, idRV, neList)) = true
        if isNewId(idRV) .

    ceq read(heap, idV, primSelector) = defaultSelect(primSelector)
        if isNewId(idV) .

    *** ceq read(new(heap, id, n), id, neList) = defaultSelect(last(neList))
    ***     if last(neList) :: PrimarySelector .

    *** ceq read(new(heap, id, n), idR, neList) = read(heap, idR, neList)
    ***     if id =/= idR .

    *** eq read(write(heap, id, selector, val), id, selector) = val .
    *** ceq read(write(heap, idW, selectorW, val), idR, selectorR) = read(heap, idR, selectorR)
    ***     if selectorW =/= selectorR or idW =/= idR .

    *** ceq read(heap, id, idSel neList) = read(heap, read(heap, id, idSel), neList)
    ***     if read(heap, id, idSel) :: Identity .
    *** eq read(write(heap, id, selector, idW), id, selector neList) = read(heap, idW, neList) .

    op assignAcc : Heap Identity Identity -> Heap .
    eq assignAcc(heap, idW, idR) = write(heap, idW, $accounts, read(heap, idR, $accounts)) .

    op defaultName : -> Name .

    op defaultSelect : PrimarySelector -> Value .
    eq defaultSelect($name) = defaultName .
    eq defaultSelect($balance) = 0 .
    eq defaultSelect($open) = ff .

    sort WriteArgs .
    op _[_]<-_ : Value Selector$Elt Value -> WriteArgs [prec 30] .
    op _[_]<-_ : Identity Selector$Elt Value -> WriteArgs [prec 30] .
    op _;_ : Heap WriteArgs -> Heap .

    eq heap ; id [ selector ]<- val = write(heap, id, selector, val) .
    eq heap ; idV [ selector ]<- val = write(heap, idV, selector, val) .

    eq read(new(heap, idV, n), idV, primSelector) = defaultSelect(primSelector) .

    ceq read(new(heap, idV, n), idRV, neList) = read(heap, idRV, neList)
        if idV =/= idRV .

    eq read(write(heap, idV, selector, val), idV, selector) = val .
    ceq read(write(heap, idWV, selectorW, val), idRV, selectorR) = read(heap, idRV, selectorR)
        if selectorW =/= selectorR or idWV =/= idRV .

    ceq read(heap, idV, idSel neList) = read(heap, read(heap, idV, idSel), neList)
        if read(heap, idV, idSel) :: Value .
    eq read(write(heap, idV, selector, idWV), idV, selector neList) = read(heap, idWV, neList) .
endfm

fmod ACCOUNT-EX{Selector :: TRIV} is
    pr ACCOUNT{Selector} .

    ops heap heapWritten heapNew heapNew2 heapBob heapWritten2 : -> Heap .
    ops Alice NName : -> Name .
    ops idAlice rId idAccAlice idBob newId rIdS idAccAliceS : -> Identity .

    eq heapWritten = heap ; idAccAlice [ $balance ]<- 100 ; idAccAlice [ $open ]<- tt ;
          idAlice [ $accounts ]<- rId ; rId [ 10 ]<- idAccAlice ; idAlice [ $name ]<- Alice  .

    eq heapNew = new(heapWritten, newId, 10) .
    eq heapBob = assignAcc(heapWritten, idBob, idAlice) .

    eq heapNew2 = heapNew ; newId [ $name ]<- NName .

    eq rIdS = read(heap, idAlice, $accounts).
    eq idAccAliceS = read(heap, rIdS, 10).
    eq heapWritten2 = heap ; idAccAliceS [ $balance ]<- 100 ; idAccAliceS [ $open ]<- tt ; idAlice [ $name ]<- Alice  .
endfm

red read(heapWritten, idAlice, $name) .
red read(heapWritten, idAccAlice, $balance) .
red read(heapWritten, idAccAlice, $open) .
red read(heapWritten, idAlice, $accounts) .
red read(heapWritten, rId, 10) .

red read(heapWritten, idAlice, $accounts) .
red read(heapWritten, idAlice, $accounts 10) .
red read(heapWritten, idAlice, $accounts 10 $balance) .
red read(heapWritten, idAlice, $accounts 10 $open) .

red read(heapNew, newId, $accounts 10 $open) .
red read(heapNew, newId, $accounts 10 $balance) .
red read(heapNew, newId, $name) .
red read(heapNew, read(heapNew, newId, $accounts 10), $balance) .

red read(heapBob, idBob, $accounts 10) .
red read(heapBob, idBob, $accounts 10 $balance) .

red read(heapNew2, newId, $name) .

red read(heapWritten2, idAlice, $name) .
red read(heapWritten2, idAlice, $accounts 10 $balance) .
